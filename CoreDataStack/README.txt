README.txt for my own research into core data pesistent store creation and locations derrived from the 'Fundamentals of Core Data '  Notes tutorial application from cocoacasts.com

https://cocoacasts.com/setting-up-the-core-data-stack

Working in branch CoreDataStack
Working Directory:/Users/frankcipolla/Workspace/CoreData/CoreDataStack/CoreDataStack/README.txt

set up Managers group.  Use this rather than putting CoreDataStack setup in the application delegate




This Chapter adds Tags to notes

The following is from:
https://cocoacasts.com/where-to-store-a-core-data-persistent-store/
Where Should You Store the Persistent Store
The answer to this question is easier than you might think if you consider the characteristics of each of the options we discussed.
tmp
The tmp directory is not a good option. The operating system doesn't guarantee that anything you store in the tmp directory is going to be around the next time your application is run.
If you only need to store data for as long as the application is running, then I recommend using an in-memory persistent store instead. An in-memory persistent store is more performant and the result is virtually identical.
Documents
As I mentioned earlier, the Documents directory is still a good candidate. It is meant to be used to store data that is generated by the user and it is backed up by iTunes and iCloud.
There is one caveat. The contents of the Documentsdirectory is accessible to the user if the application supports file sharing. This means the user can access and tamper with the contents of the persistent store. This is important to keep in mind.
Library
The Application Support directory seems to be the most suitable location for storing the persistent store. If you decide to keep the persistent store in the Library directory, I recommend to at least create a subdirectory for it. This keeps the Library directory uncluttered and organized.
The Caches directory may seem like another option, but I would advise against that. It can be cleared by the operating system and, more importantly, it is not backed up by iTunes and iCloud. The contents of the Library directory are backed up by iTunes and iCloud, with the exception of the Caches directory. That is another important element to consider.
How to Change the Location of the Persistent Store
If you are using the NSPersistentContainer class to set up and manage the Core Data stack, you need to subclass it to modify the location of the persistent store. The method you need to override is the defaultDirectoryURL() method. It specifies the default location of the persistent store on the current platform.






The following is from:

https://cocoacasts.com/setting-up-the-core-data-stack

Core Data Delete Rules:

Delete rules are one of the conveniences that make working with Core Data great. Every relationship has a delete rule. It defines what happens when the record that owns the relationship is deleted.

By default, the delete rule of a relationship is set to Nullify. Core Data supports four delete rules:
No Action
Nullify
Cascade
and Deny
No Action
If the delete rule of a relationship is set to No Action, nothing happens when the owner of the relationship is deleted. Let me illustrate this with an example. We have a category record that contains several note records. If the category record is deleted, the note records are not notified of this event. Every note record believes that it's still associated with the deleted category.

I've never had a need to use this delete rule. In most situations, you want to take some action when a record is deleted. And that's where the other delete rules come into play.


Nullify
If the delete rule of a relationship is set to Nullify, the destination of the relationship is nullified when the owner of the relationship is deleted. If a category has several notes and the category is deleted, the relationship pointing from the notes to the category is nullified. This is the default delete rule and the delete rule you will find yourself using most often.







Cascade
Cascade is useful if the data model includes one or more dependencies. For example, if an account record has a relationship to one or more user records, it may be desirable to delete every user if the account the user belongs to is deleted. In other words, the deletion of the account record cascades or trickles down to the user records it is linked to.

If you're dealing with a many-to-many relationship, though, this is often not what you want. If a tag with several notes is deleted, you don't want to delete every note linked to the tag. The notes could be associated with other tags, for example.

Deny
Deny is another powerful and useful pattern. It's the opposite of the Cascade delete rule. Instead of cascading the deletion of a record, it prevents the deletion of a record.
For example, if an account record is linked to several user records, then the account record can only be deleted if it's no longer tied to any user records. This configuration prevents the scenario in which users are no longer associated with an account.


